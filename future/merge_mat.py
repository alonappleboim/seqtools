#! /cs/bd/tools/nflab_env/bin/python3.4
import sys
import os
import re
import scipy.io as sio
import numpy as np
from scipy import sparse
import argparse
from collections import OrderedDict

# INTERPRETER = '/cs/bd/tools/nflab_env/bin/python3.4'
# if not sys.executable == INTERPRETER:  # divert to the "right" interpreter
#     import subprocess as sp
#     import os
#     scriptpath = os.path.abspath(sys.modules[__name__].__file__)
#     sp.Popen([INTERPRETER, scriptpath] + sys.argv[1:]).wait()
#     exit()


def organize_files(path, var_parsers):
    """
    Parse the files in path in light of given regexps

    :param path: a path containing files corresponding to given regexps
    :param var_parsers: a list of regexps that capture variables
    :return:
        vars - an ordered dictionary of sample variables, mapping to ordered lists of variable values
        file_map - a map from variable value tuples to matching .mat file paths
        file_list - a list of files that matched criteria, in order of iteration
        var_lists - a list of lists, one per variable, of variable values, corresponding to files in file_list
    """
    file_map, vars = {}, OrderedDict()
    file_list, var_lists = [], []
    for vp in var_parsers:
        for v in vp.groupindex.keys():
            if v not in vars:
                vars[v] = []
                var_lists.append([])
    for f in os.listdir(os.path.abspath(path)):
        for vp in var_parsers:
            m = vp.match(f)
            if m is not None: break
        if m is None: continue  # no match
        fpath = path + os.path.sep + f
        s_dict, s_vals = m.groupdict(), []
        for i, v in enumerate(vars):
            val = s_dict[v] if v in s_dict else None
            var_lists[i].append(val)
            s_vals.append(val)
        k = tuple(s_vals)
        if k in file_map:
            raise ValueError('could not differentiate between two samples: %s and %s' % (file_map[k], fpath))
        for var, val in s_dict.items():
            if val not in vars[var]: vars[var].append(val)
        file_list.append(fpath)
        file_map[k] = fpath
    return vars, file_map, file_list, var_lists


def mat2py(f):
    """
    Read a MATLAB and convert it to a python object
    :param f:  .mat file name / handle file generated by the bed2mat.py script
    :return: map chr -> data
    """
    d = sio.loadmat(f)['data']
    return {n: v for n, v in zip(d.dtype.names, d[0][0])}


def is_sparse(f):
    """
    Is the given matlab file in sparse format
    :param f:  .mat file name / handle file generated by the bed2mat.py script
    :return: True/False
    """
    d = sio.loadmat(f)['data']
    i = d.dtype.names.index('is_sparse')
    return d[0][0][19][0][0] == 1


def build_matlab_objects(vars, file_map, file_list, var_lists, args):
    """
    prep the output MATLAB objects

    :param vars: an OrderedDict of variable name -> variable values
    :param file_map: a map from variable values tuple -> file name
    :param file_list: an ordered list of files
    :param var_lists: a corresponding list of variable values per file
    :return:
        mdict - a MATLAB struct with following fields:
                * d - a cell array of #chromosomes, each holding a matrix of N_ixS, where N_i is the chromosome
                      length, and S is the number of samples.
                * l - a legend for the data, a struct, with following fields:
                      * samples - a list of sample names in the order they appear in "d{i}"
                      * vars - a struct with every field corresponding to a variable of the samples, mapping to a list
                               of values of that variable in the order of samples in "d"
                      * r - a struct with variables reshaped to a multi-dimensional array for easy access to subsets of
                            samples.
                      * c - chromosome names
                * r - a mapping of indices from the N_ixS structure of the data to multidimensional array, with every
                      dimension corresponding to a different variable, for for easy access to subsets of samples.
    """
    S = len(file_list)
    as_sparse = True
    for f in file_list:
        if not is_sparse(f):
            as_sparse = False
            break
    # init = sparse.csc_matrix if as_sparse else np.zeros
    out = {'d': [] * len(args.chr_map),
           'l': {'samples':[], 'vars': {}, 'r': {}, 'c': []},
           'r': []}
    for si, f in enumerate(file_list):
        print('xxx')
        if args.verbose:
            print('xxx')
            sys.stderr.write('processing %s...\n' % f)
        fdata = mat2py(f)
        out['l']['samples'].append(fdata['meta'])
        for chi, (ch, _) in enumerate(args.chr_map.iteritems()):
            if as_sparse:
                out['d'][]
            if ch not in fdata: continue
            out['d'][chi][:,si] = fdata[ch]
    # print(d)
    #
    #
    # if self.r:
    #     lg = OrderedDict()
    #     r = {}
    #     for f in features: lg[f.name] = sorted(f.vals)
    #     for name, _, _ in sample_stats:
    #         dims = (s[name].shape[0],) + tuple([len(f.vals) for f in features])
    #         arr = np.empty(dims)
    #         for si, arri in enumerate(MatExporter.sample2arr(samples, features, lg)):
    #             itup = (slice(None),) + arri
    #             arr[itup] = s[name][:, si]
    #         r[name] = arr
    #     for f in features:
    #         dtype = np.object if f.type is str else np.double
    #         lg[f.name] = np.array(sorted(f.vals), dtype=dtype)
    #     r['lg'] = lg
    #     s['r'] = r
    # s['doc'] = np.array('"lg" is a short for "legend", there is a complex one ("lg") for the samples'
    #                     ' and then another one for the rows of each table. "r_" is a prefix for reshaped '
    #                     'data or respective legends', dtype=str)
    # sio.savemat(fpath, {self.name: s})
    # return [self.name + '.mat']
    return {args.out_name: out}


def parse_args():

    def parse_chrmap(chr_map):
        cm = OrderedDict()
        if os.path.exists(args.chr_map):
            with open(args.chr_map) as CM:
                for line in CM:
                    c, l = line.strip().split('\t')
                    cm[c] = int(l)
        else:
            for cl in args.chr_map.split(';'):
                c, l = cl.split(':')
                cm[c] = int(l)
        return cm

    def build_default_regexp(path):
        vars = set([])
        pat_str = ''
        for f in os.listdir(path):
            if not f.endswith('.mat'): continue
            for var_val in f.replace('.mat','').split('_'):
                if '-' not in var_val: continue
                var, _ = var_val.split('-')
                if var in vars: continue
                vars.add(var)
                pat_str += '%s-(?P<%s>\w+)_' % (var, var)
        return re.compile(pat_str[:-1] + '.mat')

    p = argparse.ArgumentParser()
    p.add_argument('path', type=str, help='path to a folder containing the .mat files to merge')
    p.add_argument('name', type=str, help=('The name of the resulting matlab struct'))
    p.add_argument('--verbose', '-v', action='store_false', help='output processing info to stderr')
    p.add_argument('--output', '-o', type=str, default=None,
                   help='output file name, default is stdout')
    p.add_argument('--var_regexp', '-ve', type=str, default=None,
                   help=('Name matching python regexps that also defines the named variables. Semicolon-separated, '
                         'first matching regexp counts. '
                         'e.g. (?P<mod>\w+)_(?P<time>\d+)\.bw;(?P<mod>[\w-]+)_(?P<time>\d)\.bw '
                         'If not given, the assumed structure is <varname>-<varval>(_<varname>-<varval>)*.mat'))
    p.add_argument('--chr_map', '-cm', type=str, default='/cs/wetlab/genomics/scer/genome/sacCer3_ordered.sizes',
                   help=('A list of chr1_name:chr1_length;chr2_name:chr2_length... for the chromosomes in input .mat '
                         'files, the given order will determine the order in the output cell array. If a valid file '
                         'path is given, the data is read from file, one line per chr, tab delimited name\tlength.'))
    args = p.parse_args()
    if args.output is None:
        args.__dict__['output'] = sys.stdout
    else:
        args.__dict__['output'] = open(args.__dict__['output'], 'wb')
    args.__dict__['chr_map'] = parse_chrmap(args.chr_map)
    if args.var_regexp is None:
        args.__dict__['var_regexp'] = [build_default_regexp(args.path)]
    else:
        args.__dict__['var_regexp'] = [re.compile(x) for x in args.var_regexp.split(';')]
    return args


if __name__ == '__main__':
    args = parse_args()
    vars, file_map, file_list, var_lists = organize_files(args.path, args.var_regexp)
    mdict = build_matlab_objects(vars, file_map, file_list, var_lists, args)
    print mdict
    #sio.savemat(args.output, mdict)